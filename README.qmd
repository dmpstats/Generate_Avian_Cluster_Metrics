---
format: gfm
editor: source
---

# Generate Avian Cluster Metrics

MoveApps

Github repository: https://github.com/dmpstats/Generate_Avian_Cluster_Metrics

## Description
Generates cluster metrics from cluster-annotated locations data obtained from an upstream clustering App. Returns cluster properties summarized at track-per-cluster and/or whole-cluster levels.


## Documentation

This App calculates various metrics for clusters of animal locations grouped based on spatio-temporal proximity. It is designed to be used with tracking data that has  been processed through a spatial clustering App, requiring locations to be labelled with cluster IDs. Additionally, it provides cluster-specific summaries of behavioural activities if the input data includes annotations of animal behaviour.

App output can be rendered at both track-per-cluster and whole-cluster levels. A detailed description of the cluster metrics generated at each aggregation level is provided below in Section [Cluster Metrics](#cluster-metrics).

In practice, cluster attributes generated by this App can play a pivotal role on inferring points of interest for ground patrolling purposes and guiding response actions in animal protection efforts.



### MoveApps Worflow Dependencies

This App relies on the following prerequisites:

- Ensure the prior deployment of the App [Add Local and Solar Time](https://www.moveapps.org/apps/browser/43272925-cd24-466f-bcb9-844a09f1806b)
([GitHub](https://github.com/movestore/Convert-Times)) in the workflow, selecting the binding of local, sunset and sunrise times.

- The input data must contain a column providing cluster annotations for location points. Use Apps like [Avian Cluster Detection](https://www.moveapps.org/apps/browser/81f41b8f-0403-4e9f-bc48-5a064e1060a2) ([GitHub](https://github.com/dmpstats/Avian_Cluster_Detection)) earlier in the 
workflow to detect and identify spatial clusters from tracking data].

- Optionally, the App can produce behavioural-related cluster metrics if the input data includes the required information.  Use Apps such as [Behavioural Classification 
for Vultures](https://www.moveapps.org/apps/browser/44bb2ffa-7d40-4fad-bff5-1269995ba1a2) ([GitHub](https://github.com/dmpstats/Behavioural_Classification_for_Vultures)) earlier in the workflow to derive and bind behavioural categories to the input data.



### Input data

A `move2::move2_loc` object.

### Output data

A `move2::move2_loc` object.



### Artefacts

None


### Settings 

**Cluster ID Column** (`cluster_id_col`): character string, the name of the column in the input data indicating the cluster IDs of location points. Default: `"clust_id"`.

**Behaviour Category Column** (`behav_col`): character string, the name of the column in the input data indicating the behavioural categories of location points. Setting this to `NULL` will skip the derivation of behavioural-related cluster metrics. Default: `"behav"`.

**Cluster Metrics Aggregation Level** (`cluster_tbl_type`): choose whether to generate metrics at both the track-per-cluster level and whole-cluster levels (`"track-and-whole"`) or solely at the whole-cluster level (`"whole-only"`). Default: `"track-and-whole"`.



### Most common errors

The app will halt processing an throw an error under the following conditions:

- Failing to deploy the App 'Add Local and Solar Time' earlier in the workflow, as several of the calculated metrics rely on the presence of additional time-related columns in the input data.

- Specifying a **Cluster ID Column** or a **Behaviour Category Column** that is not included in the input data.




### Null or error handling

- **Behaviour Category Column**: if no column name is given (`NULL`), the app will not attempt to produce behavioural-based cluster metrics.



### Cluster Metrics

This section provides a full description of the cluster metrics generated in the App [Generate Avian Cluster Metrics](https://github.com/dmpstats/Generate_Avian_Cluster_Metrics), including how each attribute is calculated and their significance.

```{r preamble}
#| include: false
#| echo: false
#| message: false

library(move2)
library(httr2)
library(purrr)
library(readr)

# Helpers
source("tests/app-testing-helpers.r")

# get App secret key for decrypting test dataset
app_key <- get_app_key()

# Read (encrypted) input datasets for testing
wcs <- httr2::secret_read_rds("data/raw/vult_test_data.rds", key = I(app_key)) |> 
  purrr::pluck("wcs")

set_interactive_app_testing()

out <- rFunction(data = wcs |> slice(1:100))

track_clust_tbl_names <- out |> 
  as_tibble() |> 
  dplyr::select(-c(clust_id, individual_name_deployment_id)) |> 
  names()

clust_tbl_names <- mt_track_data(out) |> 
  select(-clust_id) |> 
  names()
```

#### Track-per-Cluster Level

The attributes listed below denote column names of a dataset where each row represents a subset of track location points spatially grouped into a cluster event. Track ID is extracted using the function `move2::mt_track_id_column()`, while cluster ID is specified by the App parameter `clust_id_col`. This dataset constitutes the events table of the `move2_loc` output object when the App setting `cluster_tbl_type` is defined to `"track-and-whole"`.

```{r}
#| include: false
#| echo: false

track_clust_details <- list(
  "`all_points`" = tibble(
    Description = "A `MULTIPOINT` geometry feature providing track location points in the cluster",
    Calculation = "Spatial combination of track-level `POINT` geometries per cluster"
  ),
  "`median_point`" = tibble(
    Description = "A `POINT` geometry locating the spatial median of track location points in the cluster",
    Calculation = "Geometric median obtained via the Weiszfeld algorithm ([`Gmedian::Weiszfeld`](https://rdrr.io/cran/Gmedian/man/Gmedian.html))"
  ),
  "`n_pts`" = tibble(
    Description = "The number of track location points in the cluster",
    Calculation = "Count number of track points in cluster"
  ),
  "`n_pts_night` and `n_pts_day`" = tibble(
    Description = "The number of night-time and day-time track location points in the cluster",
    Calculation = "Count track points in cluster grouped by column `nightpoint`"
  ),
  "`first_dttm` and `first_dttm_local`" = tibble(
    Description = "Timestamp of the first track point in the cluster, in UTC and local timezone, respectively",
    Calculation = "Find the track's earliest recorded locations in the cluster"
  ),
  "`last_dttm` and `last_dttm_local`" = tibble(
    Description = "Timestamp of the last track point in the cluster, in UTC and local timezone, respectively",
    Calculation = "Find the track's latest recorded locations in the cluster"
  ),
  "`duration_hrs`" = tibble(
    Description = "Total duration, in hours, over which the track visits the cluster, including periods where the track is outside the cluster.",
    Calculation = "The time difference between `first_dttm_local` and `last_dttm_local`"
  ),
  "`n_days_span`" = tibble(
    Description = "Total number of integer days over which the track visits the cluster, including lags during which the track is absent from the cluster",
    Calculation = "The integer difference between the date components of `first_dttm_local` and `last_dttm_local`"
  ),
  "`n_days_unique`" = tibble(
    Description = "The cumulative number of days on which the track was present in the cluster",
    Calculation = "The length of unique dates on which the track was assigned to the cluster"
  ),
  "`n_days_empty`" = tibble(
    Description = "Number of days where the track was absent from the cluster, having later revisited",
    Calculation = "The difference between `n_days_span` and `n_days_unique`"
  ),
  # "`prop_days_empty`" = tibble(
  #   Description = "The proportion of days where the track was absent from the cluster, having later revisited",
  #   Calculation = "The quotient between `n_days_empty` and `n_days_span`"
  # ),
  "`<behaviour-category>_duration` [e.g. `SFeeding_duration`, `SResting_duration`, `SRoosting_duration`]" = tibble(
    Description = "The time spent by the track in each behavioural category while visiting the cluster (unit: hours)",
    Calculation = "For each attributed behavioural class, sum over time lags between track points annotated with the cluster ID"
  ),
  # "`<behaviour-category>` [e.g. `SFeeding`, `SResting`, `SRoosting`]" = tibble(
  #   Description = "The total number of track location points assigned to each behavioural category within the cluster",
  #   Calculation = "Tally of track points annotated with the cluster ID AND each attributed behavioural class"
  # ),
  # "`med_feed_hour_local`" = tibble(
  #   Description = "The median local hour associated with 'feeding' behaviour across track location points within the cluster. This will not be generated if parameter `behav_col` is set to `NULL` or if a 'feeding' category cannot be found within the specified column through string pattern matching",
  #   Calculation = "Extract the local hour component of all track locations annotated with 'feeding' behaviour in the cluster, and calculate the median"
  # ),
  "`med_hour_local`" = tibble(
    Description = "The median local hour of track locations in the cluster",
    Calculation = "Filter the local hour component of all track locations in cluster and calculate the median"
  ),
  "`mean_attendance`" = tibble(
    Description = "The track's daily mean attendance time at the cluster (unit: hours)",
    Calculation = "Calculate the time spent by the track in the cluster per present day (excluding absent days), and compute the mean across visited days."
  ),
  "`mean_attendance_daytime`" = tibble(
    Description = "The track's daily mean attendance time at the cluster during the daytime, i.e. the period between sunset and sunrise (unit: hours)",
    Calculation = "Identical to `mean_attendance`, but including only location events where `nightpoint == 0`"
  ),
  "`mean_n_visits`" = tibble(
    Description = "The track's mean number of unique visits to the cluster per day",
    Calculation = "Run length calculations are applied to the track location points to quantify the number of cluster visits per day (excluding absent days), which are then averaged across all visited days."
  ),
  # "`mean_n_daytime_visits`" = tibble(
  #   Description = "The track's mean number of unique visits to the cluster during the daytime period per day",
  #   Calculation = "Identical to `mean_n_visits`, but including only location events where `nightpoint == 0`"
  # ),
  "`mean_night_dist`" = tibble(
    Description = "The track's daily mean distance between all night-time location points and the cluster's centroid (unit: meters)", 
    Calculation = "For each day the track visits the cluster, calculate the median distance between all night-time location points (regardless of cluster affiliation status) and the cluster centroid. Median distances are then averaged over all days to produce this metric."
  ),
  "`night_prop_250m` and `night_prop_1km`" = tibble(
    Description = "Mean proportion of all night-time track location points within, respectively, 250m and 1km from the cluster centroid, on a daily basis",
    Calculation = "Using the same distances calculated for `mean_night_dist`, get the proportions of night points located within the considered proximity distances per day, before taking the mean across all visited days"
  ),
  "`mean_arrival_dist`" = tibble(
    Description = "The mean distance between track's night-points and the centroid of the cluster on the date of arrival (i.e. first visit; unit: meters)",
    Calculation = "Filter night-time location points spanning the date of the first visit to the cluster, and compute the mean distance to the cluster's centroid"
  ),
  "`med_var_acc_<xyz>` and `sd_var_acc_<xyz>`" = tibble(
    Description = "Median and standard deviation, respectively, of Accelerometer variance across track location points within the cluster, for each active accelerometer axis (`x`, `y` and/or `z`). Only calculated when accelerometer data is available.",
    Calculation = "Median and SD of ACC variances on track points annotated with each cluster ID "
  )
)


write_rds(track_clust_details, "doc/track_clust_details.rds")

```

[^1]: If the `nightpoint` column is not present in the input data, it will derived internally based on `sunrise_timestamp` and `sunset_timestamp` columns. These columns are prerequisites that must be added using the 'Add Local and Solar Time' App.


```{r}
#| echo: false

list_rbind(track_clust_details, names_to = "Attribute Name") |> 
  knitr::kable(digits = 1) 
  #kableExtra::kable_styling(font_size = 7)
```



```{r}
#| include: false
#| echo: false

# cross-checking if output colnames match those in output description table
track_clust_details_names <- names(track_clust_details) %>%
  .[!stringr::str_detect(., "var_acc_<xyz>")] |> 
  stringr::str_remove_all("`") |> 
  stringr::str_remove("<behaviour-category>_duration \\[e.g. ") |>
  stringr::str_remove("\\]") |> 
  stringr::str_split(" and |, ") |> 
  as_vector()


symdiff(track_clust_tbl_names, track_clust_details_names)

```



#### Whole-Cluster Level

The following attributes are column names of a dataset where each row represents the properties of a cluster event, which can comprise one or multiple tracks at any given time during the cluster's existence. Cluster IDs are provided in the input data column specified by App parameter `clust_id_col`. The placement of this dataset in the output `move2_loc` object is determined by the App setting `cluster_tbl_type`:

- if `"track-and-whole"` (default), it is provided as the track table
- if `cluster_tbl_type = "whole-only"`, it is outputted as the events table 


```{r}
#| include: false
#| echo: false

clust_details <- list(
  # "`spawn_dttm_local` and `cease_dttm_local`" = tibble(
  #   Description = "Respectively, the 'spawning' and `ending` date-times of the cluster event (local timezone)",
  #   Calculation = "The earliest and latest timestamps of all point locations associated with the cluster."
  # ),
  "`spawn_dttm` and `spawn_dttm_local`" = tibble(
    Description = "The 'spawning' date-time of the cluster event, in UTC and local timezone, respectively",
    Calculation = "The earliest timestamp of all point locations associated with the cluster."
  ),
  "`cease_dttm` and `cease_dttm_local`" = tibble(
    Description = "The 'ending' date-time of the cluster event, in UTC and local timezone, respectively",
    Calculation = "The latest timestamp of all point locations associated with the cluster."
  ),
  "`centroid`" = tibble(
    Description = "A `POINT` geometry providing the coordinates of the spatial median of the cluster",
    Calculation = "Apply the Weiszfeld algorithm ([`Gmedian::Weiszfeld`](https://rdrr.io/cran/Gmedian/man/Gmedian.html)) to all location points associated with the cluster"
  ),
  "`member_tracks_n`" = tibble(
    Description = "Number of tracks containing location points affiliated with the cluster event at any point of its lifespan",
    Calculation = "Length of unique track IDs in the cluster"
  ),
  "`member_tracks_ids`" = tibble(
    Description = "List of track IDs associated with the cluster event during its lifespan",
    Calculation = ""
  ),
  "`duration_days`" = tibble(
    Description = "Total duration of the cluster event (unit: decimal days)",
    Calculation = "The difference between `cease_dttm_lcl` and `spawn_dttm_local`"
  ),
    "`span_days`" = tibble(
    Description = "Total number of integer days covered by the cluster event, including days without visiting tracks",
    Calculation = "The integer difference between the date components of `cease_dttm_lcl` and `spawn_dttm_local`"
  ),
  "`n_days_active`" = tibble(
    Description = "Number of days the cluster was active, i.e. visited by at least one track during the day",
    Calculation = "Length of unique dates of point locations affiliated to the cluster event"
  ),
  "`n_days_inactive`" = tibble(
    Description = "Number of days the cluster was inactive, i.e. no track visited during the day",
    Calculation = "The difference between `span_days` and `n_days_active`"
  ),
  # "`prop_days_inactive`" = tibble(
  #   Description = "The proportion of inactive days throughout the cluster event",
  #   Calculation = "The quotient between `n_days_inactive` and `span_days`"
  # ),
  # "`avg_feed_hour_local`" = tibble(
  #   Description = "The average local hour of track visits labelled as ‘feeding’ behaviour throughout the cluster event",
  #   Calculation = "The mean of `med_feed_hour_local` across affiliated tracks"
  # ),
  "`avg_hour_local`" = tibble(
    Description = "The average local hour of track visits throughout the cluster event",
    Calculation = "The mean of `med_hour_local` across affiliated tracks"
  ),
  "`n_points`" = tibble(
    Description = "The total number of location points comprised by the cluster",
    Calculation = "The sum of `n_pts` across associated tracks"
  ),
  "`cl_<behaviour-category>_duration` [e.g. `cl_SFeeding_duration`, `cl_SResting_duration`, `cl_SRoosting_duration`]" = tibble(
    Description = "The time spent by visiting tracks in each each behavioural category during the cluster event",
    Calculation = "The sum `<behaviour-category>_duration` (e.g. `SFeeding_duration`) across member tracks"
  ),
  #   "`n_<behaviour-category>` [e.g. `n_SFeeding`, `n_SResting`, `n_SRoosting`]" = tibble(
  #   Description = "The total number of location points under each behavioural category during the cluster event",
  #   Calculation = "The sum of location events assigned to a `<behaviour-category>` (e.g. `SFeeding`) and to the cluster ID"
  # ),
  "`avg_attendance`" = tibble(
    Description = "The daily average attendance time by member tracks at the cluster (unit: hours)",
    Calculation = "The average of `mean_attendance` across affiliated tracks"
  ),
  "`avg_attendance_daytime`" = tibble(
    Description = "The daily average attendance time spent by member tracks in the cluster during the daytime period (unit: hours)",
    Calculation = "The average of `mean_attendance_daytime` across member tracks"
  ),
  "`avg_n_visits`" = tibble(
    Description = "The average number of unique visits per day by member tracks",
    Calculation = "The average `mean_n_visits` across member tracks"
  ),
  # "`avg_n_daytime_visits`" = tibble(
  #   Description = "The average number of unique daytime visits per day by member tracks",
  #   Calculation = "The average `mean_n_daytime_visits` across member tracks"
  # ),
  "`avg_nightime_dist`" = tibble(
    Description = "The daily average distance between member tracks' night-point locations and the cluster centroid (unit: meters)",
    Calculation = "The average `mean_night_dist` across member tracks"
  ),
  "`avg_nightime_prop_250m` and `avg_nightime_prop_1km`" = tibble(
    Description = "Average proportion of member track's night-point locations within, respectively, 250m and 1km from the cluster centroid, on a daily basis",
    Calculation = "The averages of `night_prop_250m` and `night_prop_1km` across member tracks"
  ),
  "`avg_arrival_dists`" = tibble(
    Description = "The average distance between member tracks' night-points and the cluster centroid on the date of arrival (i.e. first visit; unit: meters)",
    Calculation = "The average of `mean_arrival_dist` across affiliated tracks"
  ),
  "`trks_mindist_m`" = tibble(
    Description = "The minimum distance between a **non-member** location point and the cluster centroid, during the 2 weeks leading up to and throughout the cluster event (unit: meters)",
    Calculation = "Find the closest distance from non-member location points to the cluster centroid occurring between `spawn_dttm_local - lubridate::days(14)` and `cease_dttm_lcl`"
  ),
  "`trks_n_within_25km` and `trks_n_within_50km`" = tibble(
    Description = "Number of **non-member** tracks with location points within, respectively, 25km and 50km from the cluster centroid, during the 2 weeks leading up to and throughout the cluster event",
    Calculation = "Count the non-member track IDs that have any locations within 25km and 50km of the cluster centroid between 14 days before `spawn_dttm_local` and `cease_dttm_lcl`"
  )
)


write_rds(clust_details, "doc/clust_details.rds")

```

```{r}
#| echo: false

list_rbind(clust_details, names_to = "Attribute Name") |> 
  knitr::kable(digits = 1) 
  #kableExtra::kable_styling(font_size = 7)
```



```{r}
#| include: false
#| echo: false

# cross-checking if output colnames match those in output description table
clust_details_names <- names(clust_details) |> 
  stringr::str_remove_all("`") |> 
  stringr::str_remove("cl_<behaviour-category>_duration \\[e.g. ") |>
  stringr::str_remove("\\]") |> 
  stringr::str_split(" and |, ") |> 
  as_vector()
  
symdiff(clust_tbl_names, clust_details_names)

```